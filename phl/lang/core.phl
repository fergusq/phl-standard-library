module phl::lang::core;

#info("Obsolete")
#deprecated @Void call(@List c) [
	$(@Function<@Void, @List> $(get c 0) c);
]

#info("Obsolete")
#deprecated <@T> @List<@T> box(@T obj) [
	return @List<@T> $(list obj);
]

#info("Obsolete")
#deprecated <@T> @T unbox(@List<@T> box) [
	return @T $(deref box);
]

#info("Unsafe type conversion
@param o value to be converted
@returns converted value")
<@T> @T as(@Any o) [
	return @T o;
]

#info("
Identity function
@returns the first parameter
")
<@T> @T i(@T o) [
	return o;
]

#info("
Inline If

@param cond the condition
@param then then-part
@param otherwise else-part
@returns the then-part if the condition is <tt>true</tt>, else the else part
")
<@T> @T iif(@Boolean cond, @T then, @T otherwise) [
	if (cond) return then;
	else return otherwise;
]

#info("Checks if an object is null @param obj an object @returns true if the object == 0, otherwise false")
@Boolean isNull(@Any obj) [
	if ((@Integer obj) == 0) return true;
	else return false;
]

#info("Checks if two values are equal @param obj value 1 @param obj2 value 2 @returns true if value 1 == value 2, otherwise false")
@Boolean equals(@Any obj, @Any obj2) [
	return ((@Integer obj) == @Integer obj2);
]

extern exit;

extern fprintf;
extern stderr;
@Void err_println(@String str) [
	fprintf(stderr, "%s\n", str);
]

#info("Prints a warning if an object is null @param obj the object")
@Void nullPtrCheck(@Object obj) [
	if (null == obj) {
		err_println("nullPtrCheck(): NullPtrException\n");
		doc exit(1);
	}
	return void;
]

interface @Null {
	@Boolean operator==(@Any obj) alias ==;
	@Boolean operator!=(@Any obj) alias !=;
};

struct @Object : @Any {
	field @String type {
		get:getType,
		set:setType
	};
	
	new []
	
	@Object initObject [
		return this;
	]
	
	#info("Checks if two objects are the same object (they reference to the same location). Does NOT check that they are equal. @see equals")
	@Boolean operator==(@Object obj) alias ==;
	#info("Checks if two objects are not the same object (they don't reference to the same location).")
	@Boolean operator!=(@Object obj) alias !=;
	
	auto @String #warn(CRITICAL_ONLY) [
		return this.getType() + "@" + @Integer (@Any this);
	]
};

struct @Exception {	
	field @String message {
		get:getMessage,
		set:setMessage
	};
	
	@Exception initException(@String message) [
		this.setMessage(message);
		return this;
	]
};

struct @Enumerator<@T> {
	field @T[] items;
	
	#info("Initializes a new enumerator @param items emumerated items @returns this @since PHL 1.2.5")
	@Enumerator<@T> init(@T[] items) [
		this::items = items;
		return this;
	]
	
	#info("Enumerates over the items @param task calls task for each item @since PHL 1.2.5")
	@Void operator each(@Closure<@IteratorControl, @T> task) [
		@Integer i = 0;
		while (i < this::items::size) {
			if (task(this::items[i]).isBreak()) break;
			i = i::inc;
		}
	]
	
	#info("Enumerates over the items @param job calls task for each item and index @since PHL 1.2.5")
	@Void operator enumerate (@Closure<@IteratorControl, @Integer, @T> job) [
		for (var i = 0; i < this::items::size; i=i+1) if(job(i, this::items[i]).isBreak()) break;
	]
};

interface @IteratorControl data @Integer {
	#info("Is continue? @returns <tt>true</tt> if equal to the CONTINUE constant @see CONTINUE @since PHL 1.2.5")
	@Boolean isContinue [
		return 0 == @Integer this;
	]
	#info("Is break? @returns <tt>true</tt> if equal to the BREAK constant @see BREAK @since PHL 1.2.5")
	@Boolean isBreak [
		return 1 == @Integer this;
	]
};

#info("Continue an iteration/enumeration @returns the CONTINUE constant @see BREAK @see IteratorControl.isContinue @since PHL 1.2.5")
@IteratorControl CONTINUE [
	return @IteratorControl 0;
]

#info("Stop an iteration/enumeration @returns the BREAK constant @see CONTINUE @see IteratorControl.isBreak @since PHL 1.2.5")
@IteratorControl BREAK [
	return @IteratorControl 1;
]

struct @Array<@T> {

	field @List<@T> _data {
		get: list,
		set: setData
	};

	new [
		@List<@Any> l = @List<@Any> GC_malloc(ptr_size());
		$(l:set 0 0);
		$(this:setData @List<@T> l);
	]
	
	#info("Allocates memory for the array. Faster than Array.init, but deletes the existing array. Use this when initing the array first time. @param size the size of the arry @returns this")
	#warn(NORMAL)
	#modifies_this
	@Array<@T> alloc(@Integer size) [
		@List<@Any> l = @List<@Any> GC_malloc(ptr_size()+ptr_size()*size);
		$(l:set 0 size);
		$(this:setData @List<@T> l);
		return this;
	]
	
	#info("If the array is smaller than a specific size, adds more space to the array @param size the size @returns this")
	#warn(NORMAL)
	#modifies_this
	@Array<@T> init(@Integer size) [
	
		size = $(-size this::size);
	
		@Integer i = 0;
		while ($(<i size)) {
			this.add(null);
		
			i = $(+i 1);
		}
		return this;
	]

	#info("The size of the array @returns the size of the array")
	@Integer size [
		return @Integer $(get this::list 0);
	]
	
	#info("Get an element from the array with bounds checking. @param index the index of the element @returns the element")
	#warn(NORMAL)
	@T get(@Integer index) [
		index = $(+index 1);
		if ($(<=index 0)) return null;
		if ($(>index this::size)) return null;
		return $(this::list:get index);
	]
	
	#info("Get an element from the array - no bounds checking. @param index the index of the element @returns the element")
	@T operator [] (@Integer index) [
		return $(this::list:get $(+index 1));
	]
	
	#info("Put an element to the array with bounds checking @param index the index of the element @param value the element")
	#modifies_this
	@Void set(@Integer index, @T value) [
		index = $(+index 1);
		if ($(<=index 0)) return void;
		if ($(>index this::size)) return void;
		$(this::list:set index value);
	]
	
	#info("Put an element to the array - no bounds checking @param index the index of the element @param value the element")
	#modifies_this
	@Void operator []= (@Integer index, @T value) [
		$(this::list:set $(+index 1) value);
	]

	#info("Returns the last element of the array @returns what above says")
	@T last [
		return this.get(size()-1);
	]

	#info("Add a new element to the end of the array @param value value @returns this @see Array.addAll @see Array.insert")
	#modifies_this
	@Array<@T> add(@T value) [
		@Integer oldsize = this::size;
		@List<@Any> l = @List<@Any> GC_realloc(this::list, ((oldsize + 2) * ptr_size()));
		$(set l 0 $(+oldsize 1));
		$(this:setData @List<@T> l);
		$(this:set oldsize value);
		return this;
	]
	
	#info("Add all elements of an array to the array @param array the array @returns this")
	#modifies_this
	@Array<@T> addAll(@Array<@T> array) [
		@Integer oldsize = this::size;
		@List<@Any> l = @List<@Any> GC_realloc(this::list, ((oldsize + 1 + array::size) * ptr_size()));
		$(set l 0 $(+oldsize array::size));
		$(this:setData @List<@T> l);
		for (var i = 0; i < array::size; i=i+1) {
			this[oldsize+i] = array.get(i);
		}
		return this;
	]

	#info("Remove an element from the array and shift all elements after removed element. @param index the index of the element; negative index is subtracted from the size @returns the element")
	#modifies_this
	@T remove(@Integer index) [
		
		if (index < 0) index = this::size + index;
		
		@T a = this::list[index+1];
		
		@Integer oldsize = this::size;
		@List<@Any> l = @List<@Any> GC_realloc(this::list, ((oldsize+1) * ptr_size()));
		$(set l 0 $(-oldsize 1));
		
		{
			@Integer i = index+1;
			while (i <= oldsize) {
				l[i] = l[i+1];
			
				i = i::inc;
			}
		}
		$(this:setData @List<@T> l);
		
		return a;
	]
	
	#info("Insert an element to the array and shift all elements. Elements are not removed from the array as in Array.set.
	@param index the index; negative index is subtracted from the size
	@param data_ the element
	@see Array.add
	@see Array.set")
	#modifies_this
	@Void insert(@Integer index, @T data_) [
		
		if (index < 0) index = this::size + index;
		
		index = index + 1;
		@Integer oldsize = this::size;
		@List<@Any> l = @List<@Any> GC_realloc(this::list, ((oldsize+2) * ptr_size()));
		$(set l 0 $(+oldsize 1));
		
		{
			@Integer i = oldsize+1;
			while (i > index) {
				l[i] = l[i-1];
			
				i = i::dec;
			}
		}
		l[index] = data_;
		
		$(this:setData @List<@T> l);
	]
	
	#info("Insert a group of elements to the array and shift all elements. Elements are not removed from the array as in Array.set.
	@param index the index; negative index is subtracted from the size
	@param array the group of elements
	@see Array.add
	@see Array.set
	@see Array.insert")
	#modifies_this
	@Void insertAll(@Integer index, @T[] array) [
		if (index < 0) index = this::size + index;
		
		index = index + 1;
		@Integer oldsize = this::size;
		@Integer arrsize = array::size;
		@List<@Any> l = @List<@Any> GC_realloc(this::list, ((oldsize+1+arrsize) * ptr_size()));
		$(set l 0 $(+oldsize arrsize));
		
		{
			@Integer i = oldsize+arrsize;
			while (i > index) {
				l[i] = l[i-arrsize];
				
				i = i::dec;
			}
		}
		for (var i = 0; i < arrsize; i=i+1) {
			l[index+i] = array[i];
		}
		
		$(this:setData @List<@T> l);
	]
	
	#info("Create a new array which contains all elements that apply to a specific condition. @param filter the filter @returns the new array")
	@Array<@T> filter(@Closure<@Boolean, @T> filter) [
		@Array<@T> filtered = new @Array<@T>;

		@Integer i = 0;
		while (i < this::size) {
			if (filter($(this:get i))) $(filtered:add $(this:get i));
			i = i::inc;
		}
		return filtered;
	]
	
	#info("Sorts the array @see Array.bsort")
	#modifies_this
	#deprecated("Does not work!")
	#warn(CRITICAL_ONLY)
	template @Array<@T> isort [
		var size = @Integer @Any this::list[0];
	
		for (var i = 2; i <= size; i = i + 1) {
			for (var j = 1; j <= size; j = j + 1) {
				if (this::list[i] < this::list[j]) {
					this.insert(j-1, this.remove(i-1));
					break;
				}
			}
		}
		
		return this;
	]
	
	#info("Sorts the array @see Array.bsortc")
	#modifies_this
	#deprecated("Does not work!")
	#warn(CRITICAL_ONLY)
	@Array<@T> isortc(@Closure<@Integer, @T, @T> comparator) [
		var size = @Integer @Any this::list[0];
	
		for (var i = 2; i <= size; i = i + 1) {
			for (var j = 1; j <= size; j = j + 1) {
				if (comparator(this::list[i], this::list[j]) > 0) {
					this.insert(j-1, this.remove(i-1));
					break;
				}
			}
		}
		
		return this;
	]
	
	#info("Sorts the array -- use this when you want to sort an integer array @see Array.bsort @see Array.bsortc")
	#modifies_this
	template @Array<@T> sort [
		return this.bsort();
	]
	
	#info("Sorts the array using <tt>operator <</tt> as comparator @see Array.bsortc @see Array.sort")
	#modifies_this
	#warn(CRITICAL_ONLY)
	template @Array<@T> bsort [
		var n = @Integer @Any this::list[0];
		do {
		var newn = 0;
			for (var i = 1; i <= n-1; i=i+1) {
				if (this::list[i+1] < this::list[i]) {
					var tmp = this::list[i];
					this::list[i] = this::list[i+1];
					this::list[i+1] = tmp;
					newn = i;
				}
			}
			n = newn;
		} while (n != 0);
		return this;
	]
	
	#info("Sorts the array with a comparator
	@param comparator returns a negative number if the first parameter comes before the second parameter, 0 if they are equal and otherwise a positive number
	@see Array.bsort
	@see Array.sort")
	#modifies_this
	#warn(CRITICAL_ONLY)
	@Array<@T> bsortc(@Closure<@Integer, @T, @T> comparator) [
		var n = @Integer @Any this::list[0];
		do {
			var newn = 0;
			for (var i = 1; i <= n-1; i=i+1) {
				if (comparator(this::list[i], this::list[i+1]) > 0) {
					var tmp = this::list[i];
					this::list[i] = this::list[i+1];
					this::list[i+1] = tmp;
					newn = i;
				}
			}
			n = newn;
		} while (n != 0);
		return this;
	]
	
	@Void forEach(@Closure<@IteratorControl, @T> task) [
		@Integer i = 0;
		while (i < this::size) {
			if (task(this.get(i)).isBreak()) break;
			i = i::inc;
		}
	]
	
	@Void operator each(@Closure<@IteratorControl, @T> task) [
		@Integer i = 0;
		while (i < this::size) {
			if (task(this.get(i)).isBreak()) break;
			i = i::inc;
		}
	]
	
	@Void iterate (@Closure<@IteratorControl, @Integer, @T> job) [
		for (var i = 0; i < this::size; i=i+1) if(job(i, this[i]).isBreak()) break;
	]
	@Void operator iterate (@Closure<@IteratorControl, @Integer, @T> job) [
		for (var i = 0; i < this::size; i=i+1) if(job(i, this[i]).isBreak()) break;
	]
	
	@Enumerator<@T> enumerator [
		return new @Enumerator<@T>.init(this);
	]
	
	#info("Searches a value from the array @param val the value @returns <tt>true</tt> if the array contains the value, otherwise <tt>false</tt>. Uses <tt>operator ==</tt> to compare elements")
	template @Boolean contains(@T val) [
		@Integer i = 0;
		var size = this::size;
		while (i < size) {
			if (this[i] == val) return true;
			i = i::inc;
		}
		return false;
	]
	
	#info("Creates a new array which contains all elements of the current array and a new element @param value the new element @returns the new array")
	@Array<@T> operator..(@T value) [
		@Array<@T> arr = new @Array<@T>.init(this::size+1);

		@Integer i = 0;
		while (i < this::size) {
			arr.set(i, this.get(i));
			i = i::inc;
		}
		arr.set(i, value);
		return arr;
	]
	
	template @String str [
		
		@String s = "[";
	
		@Integer i = 0;
		while (i < this::size) {
			if (i!=0) s = s + ", ";
			s = s + (@String this.get(i));
			i = i::inc;
		}
		return s + "]";
	]
	
	template auto @String [
		
		@String s = "[";
	
		@Integer i = 0;
		while (i < this::size) {
			if (i!=0) s = s + ", ";
			s = s + (@String this.get(i));
			i = i::inc;
		}
		return s + "]";
	]
	
	auto @List #warn(CRITICAL_ONLY) [
		return @List @Any this.list();
	]
};

interface @Array2<@T> data castable @Array<@Array<@T> > {
	@T get(@Integer x, @Integer y) [
		return (@Array<@Array<@T> > this).get(x).get(y);
	]
	@Void set(@Integer x, @Integer y, @T val) [
		return (@Array<@Array<@T> > this).get(x).set(y, val);
	]
};

extern GC_malloc;
extern GC_realloc;

extern strlen;
except @Function<@Integer, @String> strlen;

extern strcpy;
except @Function<@Void, @String, @String> strcpy;

extern strcat;
except @Function<@Void, @String, @String> strcat;

extern strncat;
except @Function<@Void, @String, @String, @Integer> strncat;

extern strcmp;
except @Function<@Integer, @String, @String> strcmp;

doc extern printf;

interface @String data @Pointer {
	#info("Wrapper for strlen @returns the length of the string")
	@Integer len [
		return strlen(this);
	]
	
	#info("Checks if the string is null @returns <tt>true</tt> if <tt>0 == this</tt>")
	#warn(CRITICAL_ONLY)
	@Boolean isNull [
		return 0 == @Integer @Any this;
	]

	#info("Wrapper for strcmp, understands null pointers @returns <tt>true</tt> if both strings are null or are equal")
	#warn(CRITICAL_ONLY)
	@Boolean equals(@String str) [
		if (0 == @Integer @Any this) return 0 == @Integer @Any str;
		return $(strcmp this str)::bool::not;
	]
	
	#warn(CRITICAL_ONLY)
	@String grow(@Integer size) [
		@Integer len = strlen(this);
		@String a = @String @Any alloc(len+size);
		strcpy(a, this);
		return @String a;
	]
	
	#warn(CRITICAL_ONLY)
	@String copy() [
		@Integer len = strlen(this);
		@String a = @String @Any alloc(len);
		strcpy(a, this);
		return @String a;
	]
	
	#info("Creates a new string and appends a char the end of that string @param ch the char @returns the new string")
	#warn(CRITICAL_ONLY)
	@String appendch(@Integer ch) [
		@Integer len = strlen(this);
		@String a = @String @Any alloc(len+1);
		strcpy(a, this);
		MWrite((@Integer @Any a)+len, ch);
		return @String a;
	]

	#info("Creates a new string and appends an other string to the end of the new string @param str the other string @returns the new string")
	#warn(CRITICAL_ONLY)
	@String append(@String str) [
		@String a = @String @Any alloc(strlen(this)+strlen(str)+1);
		strcpy(a, this);
		strcat(a, str);
		return @String a;
	]
	
	#info("Returns a substring @returns the substring")
	#warn(CRITICAL_ONLY)
	@String substring(@Integer begin) [
		return @String @Any (@Integer @Any this) + begin;
	]
	
	#info("Returns a char at a specific index in the string @param index the index @returns the char")
	#warn(CRITICAL_ONLY)
	@Integer charAt(@Integer index) [
		return (@Pointer<@Integer> (@Integer @Any this) + index).get() & 0xFF;
	]
	
	#info("Splits a string to an array with a separator @param delimeter the separator @returns the array")
	#warn(CRITICAL_ONLY)
	@Array<@String> split(@Integer delimeter) [
		@Array<@String> a = new @Array<@String>;
		@String curr = "";
		@Integer i = 0;
		@Integer len = this::len;
		while (i < len) {
			@Pointer<@Integer> ch = @Pointer<@Integer> (@Integer @Any this) + i;
			
			doc printf("%i (%c) %s\n", ch.get() & 0xFF , ch.get(), curr);
			
			if (ch.get() & 0xFF != delimeter) {
				curr = curr.grow(1);
				strncat(curr, @String @Any ch, 1);
			}
			else {
				a.add(curr);
				curr = "";
			}
			i = i::inc;
		}
		a.add(curr);
		return a;
	]
	
	#info("Same as String.append")
	@String operator+(@String str) alias @String.append;
	#info("Same as String.equals @returns <tt>true</tt> if strings are equal")
	@Boolean operator==(@String str) alias @String.equals;
	#info("Not String.equals @return <tt>true</tt> if strings are not equal")
	@Boolean operator!=(@String str) [
		return (this==str)::n;
	]
	
	#info("Wrapper for String.charAt")
	@Integer operator [] (@Integer index) alias @String.charAt;
};

extern sprintf;

interface @Integer {
	#warn(CRITICAL_ONLY)
	@Boolean bool [
		return @Boolean @Any this;
	]

	@Integer add(@Integer i) alias +; @Integer operator+(@Integer i) alias @Integer.add;
	@Integer sub(@Integer i) alias -; @Integer operator-(@Integer i) alias @Integer.sub;
	@Integer mul(@Integer i) alias *; @Integer operator*(@Integer i) alias @Integer.mul;
	@Integer div(@Integer i) alias /; @Integer operator/(@Integer i) alias @Integer.div;
	@Integer mod(@Integer i) alias %; @Integer operator%(@Integer i) alias @Integer.mod;
	
	@Integer andb(@Integer i) alias and; @Integer operator&(@Integer i) alias @Integer.andb;
	@Integer orb(@Integer i) alias or; @Integer operator|(@Integer i) alias @Integer.orb;
	@Integer xorb(@Integer i) alias xor; @Integer operator^(@Integer i) alias @Integer.xorb;
	
	#info("A very basic power function. @param i exponent @returns <tt>this</tt><sup><tt>i</tt></sup>")
	@Integer exp(@Integer i) [
		if (i == 0) return 1;
	
		@Integer t = this;
	
		@Integer j = 0;
		while (j < i) {
			this = this * t;
		
			j = j + 1;
		}
		return this;
	]
	
	#info("Same as Integer.exp @param i exponent @returns <tt>this</tt><sup><tt>i</tt></sup>")
	@Integer operator**(@Integer i) alias @Integer.exp;

	#info("Same as <tt>-(this)</tt> or <tt>0-this</tt>. @returns <tt>-this</tt>")
	@Integer neg [
		return $(-this);
	]

	#info("Same as <tt>-(this)</tt> or <tt>0-this</tt>. @returns <tt>-this</tt>")
	@Integer n alias @Integer.neg;

	#info("Increment by one @returns <tt>this+1</tt>")
	@Integer inc [
		return $(+this 1);
	]
	
	#info("Decrement by one @returns <tt>this-1</tt>")
	@Integer dec [
		return $(-this 1);
	]

	@Boolean eq(@Integer i) alias ==;  @Boolean operator==(@Integer i) alias @Integer.eq;
	@Boolean neq(@Integer i) alias !=; @Boolean operator!=(@Integer i) alias @Integer.neq;
	@Boolean lt(@Integer i) alias <;   @Boolean operator<(@Integer i) alias @Integer.lt;
	@Boolean le(@Integer i) alias <=;  @Boolean operator<=(@Integer i) alias @Integer.le;
	@Boolean gt(@Integer i) alias >;   @Boolean operator>(@Integer i) alias @Integer.gt;
	@Boolean ge(@Integer i) alias >=;  @Boolean operator>=(@Integer i) alias @Integer.ge;
	
	#info("Creates a new array which contains all elements in a specific range. For example
			<tt>(3..7)</tt> returns array <tt>[3, 4, 5, 6, 7]</tt>. @param i the end of the range @returns a range {<tt>this</tt>, <tt>this+1</tt>, <tt>this+2</tt>, ..., <tt>i</tt>}")
	#warn(CRITICAL_ONLY)
	@Array<@Integer> operator..(@Integer i) [
		if (i<this) return null;

		@List<@Integer> l = @List<@Integer> @Any alloc(ptr_size()*(i-this+2));
		l.set(0, i-this+1);
	
		@Integer j = this;
		@Integer k = 1;
		while (j <= i) {
			l.set(k, j);
		
			j = j::inc;
			k = k::inc;
		}
		var arr = new @Array<@Integer>;
		arr.setData(l);
		return arr;
	]
	
	#warn(CRITICAL_ONLY)
	@String str [
		@String s = @String @Any alloc(16);
		sprintf(s, "%i\0", this);
		return s;
	]
	
	auto @String #warn(CRITICAL_ONLY) alias @Integer.str;
	
	@Fraction operator || (@Integer i) [
		return new @Fraction.init(this, i);
	]
	
	auto @Fraction [
		return this || 1;
	]
	
	@Void operator times (@Closure<@IteratorControl> job) [
		for (var i = 0; i < this; i=i+1) if (job().isBreak()) break;
	]
	
	@Void operator iterate (@Closure<@IteratorControl, @Integer> job) [
		for (var i = 0; i < this; i=i+1) if (job(i).isBreak()) break;
	]
};

interface @Boolean {
	@Boolean and(@Boolean i) alias and; @Boolean operator&&(@Boolean b) alias @Boolean.and; @Boolean operator and(@Boolean b) alias @Boolean.and;
	@Boolean or(@Boolean i) alias or;   @Boolean operator||(@Boolean b) alias @Boolean.or;  @Boolean operator or(@Boolean b) alias @Boolean.or;
	@Boolean xor(@Boolean i) alias xor; @Boolean operator^(@Boolean b) alias @Boolean.xor;
	@Boolean not alias !; @Boolean n alias @Boolean.not;
	
	#info("Calls closure if true @param closure the closure")
	@Void operator ifTrue(@Closure<@Void> closure) [
		if (this) closure();
	]
	
	#info("Calls closure if false @param closure the closure")
	@Void operator ifFalse(@Closure<@Void> closure) [
		if (this); else closure();
	]
};

struct @Fraction {

	field @Integer m {
		get:m,
		set:set_m
	};
	
	field @Integer n {
		get:n,
		set:set_n
	};
	
	@Fraction init(@Integer m, @Integer n) [
	
		if (m == n) {
			m = 1;
			n = 1;
		} else {
			while (m%2 == 0 && n%2 == 0) {
				m = m / 2;
				n = n / 2;
			}
			while (m%3 == 0 && n%3 == 0) {
				m = m / 3;
				n = n / 3;
			}
			while (m%5 == 0 && n%5 == 0) {
				m = m / 5;
				n = n / 5;
			}
			while (m%7 == 0 && n%7 == 0) {
				m = m / 7;
				n = n / 7;
			}
		}
	
		this.set_m(m);
		this.set_n(n);
		return this;
	]

	manual @Integer [
		return this::m / this::n;
	]
	
	auto @String [
		return "(" + this::m + "/" + this::n + ")";
	]
	
	@String toString2() [
		return "(" + (@Integer this) + "+" + (this::m-this::m/this::n*this::n) + "/" + this::n + ")";
	]
	
	@String toDecString(@Integer decimals) [
		doc @Integer i = (this::m-this::m/this::n*this::n)*(10**decimals/this::n);
		doc @Integer zeros = i / 10;
		doc return "" + (@Integer this) + "." + (i);
	]

	@Fraction addi(@Integer i) [
		return new @Fraction.init(this::m + i*this::n, this::n);
	]
	
	@Fraction subi(@Integer i) [
		return new @Fraction.init(this::m - i*this::n, this::n);
	]
	
	@Fraction muli(@Integer i) [
		return new @Fraction.init(this::m * i, this::n);
	]
	
	@Fraction divi(@Integer i) [
		return new @Fraction.init(this::m, this::n * i);
	]
	
	@Fraction operator+(@Fraction f) alias @Fraction.addf;
	@Fraction operator-(@Fraction f) alias @Fraction.subf;
	@Fraction operator*(@Fraction f) alias @Fraction.mulf;
	@Fraction operator/(@Fraction f) alias @Fraction.divf;
	
	@Fraction addf(@Fraction f) [
		if (f::n == this::n) {
			return new @Fraction.init(this::m + f::m, this::n);
		} else {
			return new @Fraction.init(this::m * f::n + f::m * this::n, this::n * f::n);
		}
	]
	
	@Fraction subf(@Fraction f) [
		if (f::n == this::n) {
			return new @Fraction.init(this::m - f::m, this::n);
		} else {
			return new @Fraction.init(this::m * f::n - f::m * this::n, this::n * f::n);
		}
	]
	
	@Fraction mulf(@Fraction f) [
		return new @Fraction.init(this::m * f::m, this::n * f::n);
	]
	
	@Fraction divf(@Fraction f) [
		return new @Fraction.init(this::m * f::n, this::n * f::m);
	]
	
	@Boolean equals(@Fraction f) [
		return this::m * f::n == f::m * this::n;
	]
	
	@Boolean operator==(@Fraction f) alias @Fraction.equals;
	@Boolean operator!=(@Fraction f) [
		return (this == f)::not;
	]
	
	@Boolean operator<(@Fraction f) [
		return (this::m*f::n < f::m*this::n);
	]
	@Boolean operator>(@Fraction f) [
		return (this::m*f::n > f::m*this::n);
	]
	@Boolean operator<=(@Fraction f) [
		return (this::m*f::n <= f::m*this::n);
	]
	@Boolean operator>=(@Fraction f) [
		return (this::m*f::n >= f::m*this::n);
	]
};

interface @List<@T> {
	@T get(@Integer index) alias get;
	@Void set(@Integer index, @T value) #modifies_this alias set;
	
	@T operator[](@Integer index) alias get;
	@Void operator[]=(@Integer index, @T value) #modifies_this alias set;
	
	@Integer size [
		return @Integer get(this,0);
	]
	
	#warn(CRITICAL_ONLY)
	@String str [
		@String s = "[";
	
		@Integer i = 0;
		while (i < this::size) {
			if (i!=0) s = s + ", ";
			s = s + (@Integer @Any this.get(i+1))::str;
			i = i::inc;
		}
		return s + "]";
	]
	
	auto @String alias @List.str;
};

interface @NList<@T> {
	@T get(@Integer index) alias get;
	@Void set(@Integer index, @T value) #modifies_this alias set;
	
	@T operator[](@Integer index) alias get;
	@Void operator[]=(@Integer index, @T value) #modifies_this alias set;
};

interface @Pointer<@T> data @Integer {
	#warn(CRITICAL_ONLY)
	@T get alias __at1__;
	#warn(CRITICAL_ONLY)
	@T set (@T value) #modifies_this alias __at2__;
	
	@T operator:=(@T v) #modifies_this alias @Pointer.set;
	
	@T operator[](@Integer i) [
		return (@Pointer<@T> (@Integer this) + i*ptr_size()).get();
	]
	@T operator[]=(@Integer i, @T v) #modifies_this [
		(@Pointer<@T> (@Integer this) + i).set(v);
		return v;
	]
};

#info("Allocates memory @param size the size in bytes @returns a pointer to the allocated memory")
@Pointer alloc(@Integer size) [
	return @Pointer GC_malloc(size);
]

#info("A faster variant of the box-funtion")
<@T> @Pointer<@T> createReference(@T obj) [
	@Pointer<@T> ptr = alloc(ptr_size());
	$(ptr:set obj);
	return ptr;
]

#deprecated("This function is under construction and not safe to use.")
#info("Creates a reference to a <b>variable</b>. If the parameter is not a variable,
returns a pointer to a random location in the stack @param obj the <b>variable</b> @returns a reference to the variable")
<@T> @Pointer<@T> ref(@T obj) alias and;

except @Function<@Integer, @Integer> MRead;
except @Function<@Void, @Integer, @Integer> MWrite;

PIL "
argreg MRead(addr):
	put odx addr
	put oax @odx
	ret

argreg MWrite(addr, value):
	put odx addr
	@odx = value
	ret
";

__special_varargs list;

doc except ifLess4;
doc except if;
except @ExternalFunction<@List >			list;
except @ExternalFunction				get;
except @ExternalFunction				set;
except @Function<@Any, @List<@Any> >			deref;
except @Function<@Integer>				ptr_size;

PIL "
argreg lib@eq(a, b):
	if e a b goto true
		return 0
		goto out
	true:
		return 1
	out:
	ret

argreg lib@neq(a, b):
	if ne a b goto true
		return 0
		goto out
	true:
		return 1
	out:
	ret

argreg lib@lt(a, b):
	if l a b goto true
		return 0
		goto out
	true:
		return 1
	out:
	ret

argreg lib@le(a, b):
	if le a b goto true
		return 0
		goto out
	true:
		return 1
	out:
	ret

argreg lib@gt(a, b):
	if g a b goto true
		return 0
		goto out
	true:
		return 1
	out:
	ret

argreg lib@ge(a, b):
	if ge a b goto true
		return 0
		goto out
	true:
		return 1
	out:
	ret

argreg lib@not(a):
	if e a 0 goto true
		return 0
		goto out
	true:
		return 1
	out:
	ret

argreg lib@add(a, b):
	_t = +(a, b)
	return _t
	ret
argreg lib@sub(a, b):
	_t = -(a, b)
	return _t
	ret
argreg lib@mul(a, b):
	_t = *(a, b)
	return _t
	ret
argreg lib@div(a, b):
	_t = /(a, b)
	return _t
	ret
argreg lib@mod(a, b):
	_t = %(a, b)
	return _t
	ret
argreg lib@and(a, b):
	_t = &(a, b)
	return _t
	ret
argreg lib@or(a, b):
	_t = |(a, b)
	return _t
	ret
argreg lib@xor(a, b):
	_t = ^(a, b)
	return _t
	ret
	
argreg lib@at1(a):
	oax = @(a)
	ret
	
argreg lib@at2(a,b):
	proceed @(a,b)
	ret

extern GC_malloc

varargs list(size):
	t1 = *(size, osize)
	t1 = +(t1, osize)
	t1 = +(t1, osize)
	ptr = GC_malloc(t1)
	ptr2 = ptr
	i = 0
	while1:
	if g i size goto outwhile1
		return i
		put odx arg oax
		return ptr2
		read @oax odx
		i = +(i, 1)
		ptr2 = +(ptr2, osize)
	goto while1 outwhile1:
	return ptr
	ret

argreg get(list, id):
	obx = *(id, osize)
	oax = +(list, obx)
	put oax @oax
	ret

argreg set(list, id, value):
	obx = *(id, osize)
	odx = +(list, obx)
	@odx = value
	ret

argreg deref(ptr):
	oax = @(ptr)
	ret

argreg ptr_size():
	return osize
	ret
";
